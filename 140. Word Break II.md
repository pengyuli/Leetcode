# Word Break II
> Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.
> 
> Note:
> 
> The same word in the dictionary may be reused multiple times in the segmentation.
> You may assume the dictionary does not contain duplicate words.

	Example 1:
	
	Input:
	s = "catsanddog"
	wordDict = ["cat", "cats", "and", "sand", "dog"]
	Output:
	[
	  "cats and dog",
	  "cat sand dog"
	]
	Example 2:
	
	Input:
	s = "pineapplepenapple"
	wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
	Output:
	[
	  "pine apple pen apple",
	  "pineapple pen apple",
	  "pine applepen apple"
	]
	Explanation: Note that you are allowed to reuse a dictionary word.
	Example 3:
	
	Input:
	s = "catsandog"
	wordDict = ["cats", "dog", "sand", "and", "cat"]
	Output:
	[]
	
## 思路
用dp, dp每一步存一个list, 对于dp[i]来说 如果set中有string.substring(j, i)那么就把j存到dp[i]中. dp[i]中相当于存了所有能到达他的string.
这样如果最后一步dp[n]不为空说明可以找到, 然后利用dfs找到
### 复杂度
time O(n^2) space O(n^2)
### 代码

```
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        List<String> res = new ArrayList<>();
        List<Integer>[] dp = new ArrayList[s.length() +1];
        for (int i = 0; i < dp.length; i++) {
            dp[i] = new ArrayList<>();
        }
        dp[0].add(0);
        Set<String> set = new HashSet<>(wordDict);
        for (int i = 1; i <= s.length(); i++) {
            for (int j =0; j < i; j++) {
                if (!dp[j].isEmpty() && set.contains(s.substring(j, i))) {
                    dp[i].add(j);
                }
            }
        }
        getResult(dp, res, s.length(), "", s);
        
        return res;
    }
    
    private void getResult(List<Integer>[] dp, List<String> res, int index, String cur, String s) {
        if (index == 0) {
            res.add(cur.trim());
            return;
        }
        for (int preIndex: dp[index]) {
            getResult(dp, res, preIndex, s.substring(preIndex, index) + " " + cur, s);
        }
    }
     
    
}
```
## 思路
正常的dfs来搜索会出现TLE, 所以需要有个Map来记录每个字符对应的ArrayList这样可以减少重复搜索
### 复杂度
Time complexity : O(n^3)O(n 
3
 ). Size of recursion tree can go up to n^2n 
2
 . The creation of list takes nn time.

Space complexity : O(n^3)O(n 
3
 ).The depth of the recursion tree can go up to nn and each activation record can contains a string list of size nn. 
### 代码
```
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        Map<String, List<String>> map = new HashMap<>();
        helper(s, wordDict, map);
        return map.get(s);
    }
    private void helper(String s, List<String> wordDict, Map<String, List<String>> map) {
        if (map.containsKey(s)) {
            return;
        }
        if (s.length() == 0) {
            return;
        }
        List<String> res = new ArrayList<>();
        //因为s.substring(i)会报错, 这里处理这一特例
        if (wordDict.contains(s)) {
            res.add(s);
        }
        for (int i = 1; i < s.length(); i++) {
            String word = s.substring(0,i);
            if (!wordDict.contains(word)) {
                continue;
            }
            helper(s.substring(i), wordDict, map);
            List<String> subRes = map.get(s.substring(i));
            for (String str : subRes) {
                res.add(word + " " + str);
            }
        }
        map.put(s, res);
    }
}
```