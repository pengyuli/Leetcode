# Unique Paths III
On a 2-dimensional grid, there are 4 types of squares:

1 represents the starting square.  There is exactly one starting square.
2 represents the ending square.  There is exactly one ending square.
0 represents empty squares we can walk over.
-1 represents obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.

 

> Example 1:
> 
> Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
> Output: 2
> Explanation: We have the following two paths: 
> 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
> 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
> Example 2:
> 
> Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
> Output: 4
> Explanation: We have the following four paths: 
> 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
> 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
> 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
> 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
> Example 3:
> 
> Input: [[0,1],[2,0]]
> Output: 0
> Explanation: 
> There is no path that walks over every empty square exactly once.
> Note that the starting and ending square can be anywhere in the grid.
> 

## 思路
用dfs, 可以用改变grid里面已经访问的数字来记录已经访问的grid。 记录所有0和2的个数， 然后确保退出时候步数和个数相同

### Code

```java
class Solution {
    int count = 0;
    public int uniquePathsIII(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int x = 0, y = 0, space = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    x= i;
                    y = j;
                }
                else if (grid[i][j] >= 0) {
                    space++;
                }
            }
        }
        helper(grid,x, y, space);
        return count;
    }
    
    private void helper(int[][] grid,int i, int j, int step) {
        if (i < 0 || i >= grid.length || j<0 || j >= grid[0].length || grid[i][j]< 0) {
            return;
        }
        if (grid[i][j] == 2 ) {
            if (step == 0) count++;
            return;
        }
        grid[i][j] = -1;
        helper(grid,i-1, j, step-1);
        helper(grid,i+1, j, step-1);
        helper(grid,i, j-1, step-1);
        helper(grid,i, j+1, step-1);
        grid[i][j]  = 0;
        
    }
    
}
```