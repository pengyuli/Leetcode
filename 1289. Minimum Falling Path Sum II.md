# Minimum Falling Path Sum II
Given a square grid of integers arr, a falling path with non-zero shifts is a choice of exactly one element from each row of arr, such that no two elements chosen in adjacent rows are in the same column.

Return the minimum sum of a falling path with non-zero shifts.

 

> Example 1:
> 
> Input: arr = [[1,2,3],[4,5,6],[7,8,9]]
> Output: 13
> Explanation: 
> The possible falling paths are:
> [1,5,9], [1,5,7], [1,6,7], [1,6,8],
> [2,4,8], [2,4,9], [2,6,7], [2,6,8],
> [3,4,8], [3,4,9], [3,5,7], [3,5,9]
> The falling path with the smallest sum is [1,5,7], so the answer is 13.

## 思路
用DP,  初始状态 dp[0][j] = arr[0][j], 转移方程 dp[i][j] = arr[i][j] + dp[i-1][*(除了j)], 结果 math.min（dp[m-1][*]）

复杂度 O(N^3) 因为每次计算最小值还需要O(N)

### 代码
```
class Solution {
    public int minFallingPathSum(int[][] arr) {
        int m = arr.length;
        int[][] dp = new int[m][m];
        int res = Integer.MAX_VALUE;
        for (int i =0; i < m; i++) {
            for (int j = 0; j < m; j++) {
                if (i == 0) {
                    dp[i][j] = arr[i][j];
                } else {
                    int pre = Integer.MAX_VALUE;
                    for (int k = 0; k < m; k++) {
                        if (k != j && dp[i-1][k] < pre) {
                            pre = dp[i-1][k];
                        }
                        dp[i][j] = arr[i][j] + pre;
                    }
                    if (i == m -1 && res > dp[i][j]) {
                        res = dp[i][j];
                    }
                }
            }
        }
        return res;
    }
}
```


