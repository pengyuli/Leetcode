# Remove All Adjacent Duplicates in String II
You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make k duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

 

Example 1:

Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
Example 2:

Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
Example 3:

Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"

## 思路
用stack, stack里面记录char和出现的次数, 如果达到就出栈
Time O(n)

### 代码

```
class Solution {
    class Adjacent {
        char ch;
        int freq;

        public Adjacent(char ch, int freq) {
            this.ch = ch;
            this.freq = freq;
        }
    }
    
    public String removeDuplicates(String s, int k) {
        StringBuilder sb = new StringBuilder();
        Stack<Adjacent> stack= new Stack<>();
        for (char c: s.toCharArray()) {
            if (stack.isEmpty() || stack.peek().ch != c) {
                stack.push(new Adjacent(c, 1));
            } else {
                stack.peek().freq++;
                if (stack.peek().freq == k) {
                    stack.pop();
                }
            }
        }
        while (!stack.isEmpty()) {
            Adjacent peek = stack.pop();
            sb.append(String.valueOf(peek.ch).repeat(peek.freq));
        }
        return sb.reverse().toString();
    }
}

```