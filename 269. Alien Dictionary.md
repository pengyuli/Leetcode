# Alien Dictionary
> There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

	Example 1:
	
	Input:
	[
	  "wrt",
	  "wrf",
	  "er",
	  "ett",
	  "rftt"
	]
	
	Output: "wertf"
	Example 2:
	
	Input:
	[
	  "z",
	  "x"
	]
	
	Output: "zx"
	Example 3:
	
	Input:
	[
	  "z",
	  "x",
	  "z"
	] 
	
	Output: "" 
	
	Explanation: The order is invalid, so return "".

## 思路
拓扑排序+BFS map里面用arraylist而不用set是因为set会合并相同的char, 导致indgree和map not sync. 
### 复杂度
time O(n) Space O(n)
### 代码

```
class Solution {
    public String alienOrder(String[] words) {
        Map<Character, Integer> indgree = new HashMap<>();
        Map<Character, ArrayList<Character>> map = new HashMap<>();
        for (String word : words) {
            for (char c : word.toCharArray()) {
                indgree.put(c, 0);
                map.put(c, new ArrayList<>());
            }
        }
        for (int i = 0; i < words.length-1; i++) {
            String cur = words[i];
            String next = words[i+1];
            if (cur.length() > next.length() && cur.startsWith(next)) {
            return "";
        }
            int len = Math.min(cur.length(), next.length());
            for (int j = 0; j < len; j++) {
                if (cur.charAt(j) != next.charAt(j)) {
                    map.get(cur.charAt(j)).add(next.charAt(j));
                    indgree.put(next.charAt(j), indgree.get(next.charAt(j)) +1);

                    break;
                        
                    
                }
            }
        }
        // System.out.print("map is" + map);
        // System.out.print("indgree is" + indgree);
        StringBuilder sb = new StringBuilder();
        Queue<Character> q = new LinkedList<>();
        for (char c : indgree.keySet()) {
            if (indgree.get(c) == 0) {
                q.offer(c);
            }
        }
        // System.out.print("queue is" + q);
        while (!q.isEmpty()) {
            char cur = q.poll();
            sb.append(cur);
            for (char c : map.get(cur)) {
                indgree.put(c, indgree.get(c) -1);

                if (indgree.get(c) == 0) {
                    q.offer(c);
                }
             } 
            
        }
        return sb.length() < indgree.size()? "": sb.toString();
        
        
    
    }
}
```